#!/bin/bash

# partitioning - Partitioning functions - Dialog version

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Lution scripts by Carl Duff and AUI scripts by HelmuthDU

# Please read the introduction in the README file

# -----------------------      ------------------------
# Functions         Line       Functions           Line
# -----------------------      ------------------------
# CheckParts          24       BuildPartitionLists 269
# Partitioning        75       UpdateArray         293
# Parted              99       AllocateRoot        382
# AutoPartition      103       CheckPartition      404
# AutoWarning        152       AllocateSwap        460
# FileSystem         167       SetSwapFile         476
# SetLabel           232       MorePartitions      520
# EditLabel          247       MakePartition       560
# -----------------------      ------------------------

CheckParts() { # First check of available partitions on the system
  # Test for existing partitions
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  local Partitions=0
  for i in $ShowPartitions
  do
    (( Partitions+=1 ))
    break
  done
  # If no partitions exist, offer cfdisk to create (or exit)
  if [ $Partitions -eq 0 ]
  then
    while [ $Partitions -eq 0 ]
    do
      local Message="There are no partitions on the device, and at least one partition is needed for the root directory. If you choose to do nothing now, the script will terminate to allow you to partition in some other way."
      Partitioning # Partitioning options
      if [ $Proceed -eq 3 ]; then
        PrintOne "Exiting"
        exit
      fi
      # Check that partitions have been created
      ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      Partitions=0
      for i in $ShowPartitions
      do
        (( Partitions+=1 ))
        break
      done
    done
    # Call function to generate an array of partitions
    BuildPartitionLists # This is a first call
  else
    # Generate an array of partitions
    BuildPartitionLists # This is a first call
    Partitions=0
    # Copy array to variable for display
    ExistingPartitions=""
    for part in ${PartitionList}
    do
      ExistingPartitions="$ExistingPartitions \n ${PartitionArray[$Partitions]}"
      (( Partitions+=1 ))
    done
    local Message="Here is a list of available partitions on all connected devices:\n$ExistingPartitions\n\nIf you choose to do nothing now, the script will next enable you to allocate the existing partitions."
    Partitioning # Partitioning options
    # Call function to regenerate the array of partitions
    MakePartitionList
  fi
}

Partitioning() {
  Proceed=""
  AutoPart=0 # Set flag to 'off' by default
  while [ -z $Proceed ]
  do
    dialog --backtitle "$Backtitle" --title " - Partitioning - " --no-shadow --cancel-label "Do nothing" --menu "$Message" 20 55 2 \
        "Manual" "Open cfdisk so I can partition manually" \
        "Auto" "Allow feliz to partition the whole device" 2> output.file
    Proceed=$(cat output.file)
    case $Proceed in
      "Manual") cfdisk 2>> feliz.log
        tput setf 0 # Change foreground colour to black temporarily to hide error message
        partprobe 2>> feliz.log #Inform kernel of changes to partitions
        tput sgr0 # Reset colour
        ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      ;;
      "Auto") AutoPartition
      ;;
      *) Proceed=3
     esac
  done
}

AutoPartition() {
# Called from option 2) within Partitioning()
AutoPart=0
until [ ${AutoPart} -gt 0 ]
do
  DiskDetails=`lsblk -l | grep 'disk' | awk '{print $1}'`
  UseDisk=$DiskDetails # If more than one, UseDisk will be first
  # Count lines. If more than one disk, ask user which to use
  local Counter=0
  for i in $DiskDetails
  do
    (( Counter+=1 ))
    Drives[$Counter]=$i
  done
  if [ $Counter -gt 1 ]
  then
    UseDisk="" # Reset for user choice
    Counter=0
    ExistingPartitions="" # Prepare variable
    for i in $DiskDetails
    do
      (( Counter+=1 ))
      ExistingPartitions="$ExistingPartitions $i\n"
    done
    while [ -z $UseDisk ]
    do
      local Message="There are $Counter devices available\n $ExistingPartitions\nWhich do you wish to use for installation?\n(Remember, this is auto-partition, and any data on the chosen device will be lost)"
      dialog --backtitle "$Backtitle" --title " - auto-partition - " --no-shadow --inputbox "\n$Message\n" 18 50 2> output.file
      UseDisk=$(cat output.file)
      #  Check entry against list
      for i in $DiskDetails
      do
        if [ $i = $UseDisk ]; then
          Counter=1
        fi
      done
      if [ $Counter -ne 1 ]; then
        UseDisk=""
      fi
      AutoWarning
    done
  else
    AutoWarning
  fi
done
}

AutoWarning() {
while :
do
  dialog --backtitle "$Backtitle" --title " - auto-partition - " --no-shadow --yesno "\nThis will erase any data on '${UseDisk}'\nAre you sure you wish to continue?\n" 10 40
  case $? in
    0) RunAutoPart
      if [ ${Home} = "Y" ]; then
        ShowPart3=`lsblk -l | grep "${UseDisk}3" | awk '{print $4}'` >/dev/null
        PrintHome="Home partition: ${AddPartList[0]} ${AddPartType[0]} $ShowPart3"
      fi
      dialog --backtitle "$Backtitle" --title " auto-partition " --no-shadow --msgbox "Partitioning of ${GrubDevice} successful\n\n$ShowPart1 ${SwapPartition}${SwapFile}\n $ShowPart2  ${RootPartition} ${RootType}\n$PrintHome\n\nYou will have the opportunity to review these later." 15 40
      break
      ;;
    *) UseDisk=""
      break
  esac
done
}

FileSystem() {
  case $1 in
  "nocancel") local Cancel="--$1"
  ;;
  *) local Cancel="--cancel-label $1"
  esac
  dialog --backtitle "$Backtitle" --title " - Partitioning - " --no-shadow ${Cancel} --menu "\n$Message\n" 16 50 4 \
        "ext2" "-" \
        "ext3" "-" \
        "ext4" "-" \
        "btrfs" "-" 2> output.file
  if [ $? -gt 0 ]; then # If <Cancel> option selected
    PartitionType=""
  else
    PartitionType=$(cat output.file)
  fi
}

EditLabel() { # Called by AllocateRoot, AllocateSwap and MorePartitions
# Allows user to keep, edit or remove an existing label
Label="${Labelled[$1]}"
if [ -n ${Label} ]; then
  dialog --backtitle "$Backtitle" --title " - Edit Partition Label - " --no-shadow --menu "The partition you have chosen is labelled '${Label}'" 18 50 3 \
        "1" "Keep existing label" \
        "2" "Delete label" \
        "3" "Enter a new label" 2> output.file
  Response=$(cat output.file)
  case $Response in
    1) LabellingArray[$PartitionID]=$Label # Keep saved label
    ;;
    2) LabellingArray[$PartitionID]="" # Empty label
    ;;
    *) dialog --backtitle "$Backtitle" --title " - Edit Partition Label - " --no-shadow --inputbox "$PartitionID \nEnter a new label ..." 10 50 2> output.file
      Response=$(cat output.file)
      LabellingArray[$PartitionID]=$Response # Save new label
  esac
fi
}

AllocateRoot() {
  # Display partitions for user-selection
  # Uses list of all available partitions in PartitionList
  Remaining=""
  Partition=""
  PartitionType=""
  listgen2 "$PartitionList" "PartitionArray"
  dialog --backtitle "$Backtitle" --title " - Partitions - " --no-shadow --ok-button "Select" --nocancel --menu "Please now select a partition to use for /root\n" 14 60 $Counter "${Options[@]}" 2> output.file
  Reply=$(cat output.file)
  PassPart="$Reply"
  SetLabel "$Reply"
  UpdateArray # Remove the selected partition from $PartitionArray[]
  local Counter=0
  for i in ${PartitionList}
  do
    (( Counter+=1 ))
    if [ $i = $Reply ]; then
      Partition="$i"
      RootPartition="/dev/$i"
      # Before going to FileSystem, see if the partition is already formatted
      CheckPartition
      # Now select a filesystem
      if [ ${CurrentType} ]; then
        local Message="$Message\nYou can choose to leave it as it is, but should be aware that not reformatting the root partition can have unexpected consequences."
        FileSystem "None"
      else
        local Message="Please now select the file system for ${Partition} ... It is not recommended to mix the btrfs file-system with others.\n"
        FileSystem "None"
      fi
      if [ -z ${PartitionType} ] && [ ${CurrentType} ]; then
        RootType=""
      else
        RootType="${PartitionType}"
        Label="${Labelled[${PassPart}]}"
        if [ -n "${Label}" ]; then
          EditLabel $PassPart
        fi
      fi
    else
      Remaining="$Remaining $i" # Add next available partition
    fi
  done
  PartitionList=$Remaining      # Replace original PartitionList with remaining options
}

CheckPartition() {
# Finds if there is an existing file system on the selected partition
CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
if [ ${CurrentType} ]; then
  local Message="The selected partition ${Partition} is currently formatted to ${CurrentType}\nReformatting it will remove all data currently on it."
else
 local Message=""
fi
}

AllocateSwap() {
# ~ Checks if there are remaining partitions and allows selection for swap ~
if [ -n "${PartitionList}" ]         # Partitionlist as updated by AllocateRoot
then
  SwapPartition=""                   # Make sure other variables are empty
  SwapFile=""
  declare -a CopyArray               # Prepare empty array for passing to listgen2
  local Counter=0                    # Start counter at 1
  for p in "${PartitionArray[@]}"    # Copy each item from PartitionArray .....
  do
    CopyArray[${Counter}]=${PartitionArray[$Counter]} # ... into CopyArray for display in menu
    (( Counter+=1 ))                 # Counter is always 1 ahead of array elements
  done
                                     # Prepare for passing to listgen2
  CopyArray[${Counter}]="Swapfile"   # Add 'Swapfile' to array of available partitions
  PickFrom="$PartitionList Swapfile" # and make copy of PartitionList with 'Swapfile' added
  listgen2 "$PickFrom" "CopyArray"
  dialog --backtitle "$Backtitle" --title " - Partitions - " --no-shadow --ok-button "Select" --cancel-button "None" --menu "Select a partition for swap from the ones that remain, or you can allocate a swap file. Warning: Btrfs does not support swap files." 14 60 $Counter "${Options[@]}" 2> output.file
  RetVal=$?
  if [ $RetVal -ne 0 ]; then         # If <Cancel> selected
    Result="Done"                    # Prepare reporting variable before exiting
    SwapPartition=""
    break
  fi
  Result=$(cat output.file)          # Save selected partition ID
  if [ $Result = "Swapfile" ]; then
    SetSwapFile                      # Function call to set swapfile size
    SwapPartition=""
    break
  else
    SwapPartition="/dev/$Result"     # All other options are a partition in form 'sd*n'
    IsSwap=`sudo blkid ${SwapPartition} | grep 'swap' | awk '{print $1}'` # Check if already a swap
    if [ -n "$IsSwap" ]; then                                     # If it is, offer yes/no ...
      dialog --backtitle "$Backtitle" --title " Swap Partition " --yesno "$Result is already formatted as a swap partition, Do you wish to reformat it?" 8 40
      RetVal=$?
      case $RetVal in                # ... and use $? (exit status) to set variable
      0) MakeSwap="Y"                # used during installation
      ;;
      *) MakeSwap="N"
      esac
    fi
    Label="${Labelled[${Result}]}"   # Recover the label found earlier (associative array index 'sd*n')
    if [ -n "${Label}" ]; then       # If there is a label one ...
      EditLabel "$Result"            # Pass partition ID to two functions
      SetLabel "$Result"
    fi
    PassPart="$Result"
    UpdateArray                      # Remove the selected partition ($Result) from $PartitionArray
    Remaining=""
    for p in "${PartitionArray[@]}"  # Then go through the array ...
    do
      First=`echo $p | awk '{print $1}'` # Separate first field, and use it
      Remaining="$Remaining $First"      # in building the new list
    done
  fi
fi
PartitionList=$Remaining             # Replace original PartitionList with remaining options
}

SetSwapFile() {
LoopRepeat="Y"
local Message="Allocate the size of your swap file (M = Megabytes, G = Gigabytes) [eg: 512M or 2G]"
while [ ${LoopRepeat} = "Y" ]
do
  dialog --backtitle "$Backtitle" --title " - Swapfile - " --no-shadow --inputbox "\n$Message\n" 18 50 2> output.file
  Response=$(cat output.file)
  RESPONSE="${Response^^}"
  # Check that entry includes 'M or G'
  CheckInput=(`echo $RESPONSE | grep "G\|M"`)
  echo
  if [ -z ${CheckInput} ]; then
    local Message="You must include M or G\n$Message"
    SwapFile=""
  else
    SwapFile=$RESPONSE
    LoopRepeat="N"
  fi
  if [ ${LoopRepeat} = "N" ]; then
    break
  fi
done
}

MorePartitions() { # For any unallocated partitions. Uses PartitionList and PartitionArray
  #  as updated by AllocateSwap()
  local Elements=0
  AddedToRemaining=0
  for i in ${PartitionList} # Count items in string array
  do
    (( Elements+=1 ))
  done
  while [ $Elements -gt 0 ]
  do
    Remaining=""
    listgen2 "$PartitionList" "PartitionArray"
    dialog --backtitle "$Backtitle" --title " - Partitions - " --no-shadow --ok-button "Select" --cancel-button "Done" --menu "The following partitions remain unallocated.\nIf you wish to use one, select it from the list, or choose 'Done' to finish partitioning." 18 60 $Counter "${Options[@]}" 2> output.file
    Response=$?
    if [ $Response -gt 0 ]; then # ie: <Done>
      Elements=0
      break
    else
      Result=`cat output.file`
      PassPart=$Result
      SetLabel "$Result"
      UpdateArray # Remove the selected partition from $PartitionArray[]
    fi
    for Part in ${PartitionList} # Iterate through the list to find selected item
    do
      Partition=""
      PartitionType=""
      if [ $Part = $Result ]; then # Selected item
        Partition="/dev/$Part"
        MakePartition # Call complete details
        Label="${Labelled[${PassPart}]}"
        if [ -n "${Label}" ]; then
          EditLabel $PassPart
        fi
      else # This part is not selected
        Remaining="$Remaining $Part" # Add unused partition to temp list
        (( AddedToRemaining+=1 )) # And increment the count
      fi
    done
    PartitionList=$Remaining  # Replace original PartitionList with temp list
    Elements=$AddedToRemaining
  done
  # Ensure that if AddPartList (the defining array) is empty, all others are too
  if [ -z ${#AddPartList[@]} ]
  then
    AddPartList=""
    AddPartMount=""
    AddPartType=""
  fi
}

MakePartition() { # Called by MorePartitions
  # Add the selected partition to the array for extra partitions
  # 1) Save to AddPartList (eg: /dev/sda5)
  ExtraPartitions=${#AddPartList[@]}
  AddPartList[$ExtraPartitions]="${Partition}"
  CheckPartition   # Before going to FileSystem, check the partition
  if [ ${CurrentType} ]; then
    local Message="You can choose to leave it as it is, by selecting 'Done', but not reformatting an existing partition man have unexpected consequences."
  fi
  # 2) Select filesystem
  FileSystem "None"
  AddPartType[$ExtraPartitions]="${PartitionType}"  # Add it to AddPartType list
  # 3) Get a mountpoint
  LoopRepeat="Y"
  local Message="Enter a mountpoint for ${Partition} (eg: /home)"
  while [ ${LoopRepeat} = "Y" ]
  do
    dialog --backtitle "$Backtitle" --title " - Partitioning - " --no-shadow --inputbox "\n$Message\n" 18 50 2> output.file
    Response=$(cat output.file)
    # Check that entry includes '/'
    CheckInput=(`echo $Response | cut -c1`)
    case ${CheckInput} in
      "") PrintOne "You must enter a valid name"
          PartMount=""
          ;;
      *) if [ ${CheckInput} != "/" ]; then
            PartMount="/${Response}"
        else
            PartMount="${Response}"
        fi
    esac
    # Check that the mountpoint has not already been used
    MountPointCounter=0
    if [ -z ${AddPartMount} ]; then
      LoopRepeat="N"
    else
      # Go through AddPartMount checking each item against PartMount
      for MountPoint in ${AddPartMount}
      do
        MountPointCounter=$((MountPointCounter+1))
        if [ $MountPoint = $PartMount ]; then
          local Message="${_Mountpoint} ${PartMount} ${_MakePartition6}\n$Message"
        else
          LoopRepeat="N"
          break
        fi
      done
    fi
    if [ ${LoopRepeat} = "N" ]
    then
      break
    fi
  done
  AddPartMount[$ExtraPartitions]="${PartMount}"
}
